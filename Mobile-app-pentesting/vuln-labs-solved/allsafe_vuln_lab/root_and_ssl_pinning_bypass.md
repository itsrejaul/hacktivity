### Root and SSL Pinning Bypass with one command

............................................

How it's works:

1. Save this file with "allsafe_rssl_bypass.js" extention (you can use your comfortable file name)
2. first run frida server from adb shell (data/local/tmp/)
3. Run this script like this -

```
rida -U -f infosecadventures.allsafe -l allsafe_rssl_bypass.js
```

.........................................

```

  // bypass_rootbeer_minimal.js
  Java.perform(function () {
  try {
  var RootBeer = Java.use('com.scottyab.rootbeer.RootBeer');
  if (RootBeer && RootBeer.isRooted) {
  RootBeer.isRooted.implementation = function () {
  console.log('[frida] RootBeer.isRooted() called â€” returning false');
  return false;
  };
  console.log('[frida] Hook installed: RootBeer.isRooted -> false');
  } else {
  console.log('[frida] RootBeer class or isRooted method not found');
  }
  } catch (err) {
  console.log('[frida] Error hooking RootBeer: ' + err);
  }
  });

// ssl pinning bypass script ..

setTimeout(function(){
Java.perform(function (){
console.log("");
console.log("[.] Cert Pinning Bypass/Re-Pinning");

           var CertificateFactory = Java.use("java.security.cert.CertificateFactory");
           var FileInputStream = Java.use("java.io.FileInputStream");
           var BufferedInputStream = Java.use("java.io.BufferedInputStream");
           var X509Certificate = Java.use("java.security.cert.X509Certificate");
           var KeyStore = Java.use("java.security.KeyStore");
           var TrustManagerFactory = Java.use("javax.net.ssl.TrustManagerFactory");
           var SSLContext = Java.use("javax.net.ssl.SSLContext");

           // Load CAs from an InputStream
           console.log("[+] Loading our CA...")
           var cf = CertificateFactory.getInstance("X.509");

           try {
               var fileInputStream = FileInputStream.$new("/data/local/tmp/cert-der.crt");
           }
           catch(err) {
               console.log("[o] " + err);
           }

           var bufferedInputStream = BufferedInputStream.$new(fileInputStream);
               var ca = cf.generateCertificate(bufferedInputStream);
           bufferedInputStream.close();

               var certInfo = Java.cast(ca, X509Certificate);
           console.log("[o] Our CA Info: " + certInfo.getSubjectDN());

           // Create a KeyStore containing our trusted CAs
           console.log("[+] Creating a KeyStore for our CA...");
           var keyStoreType = KeyStore.getDefaultType();
           var keyStore = KeyStore.getInstance(keyStoreType);
           keyStore.load(null, null);
           keyStore.setCertificateEntry("ca", ca);

           // Create a TrustManager that trusts the CAs in our KeyStore
           console.log("[+] Creating a TrustManager that trusts the CA in our KeyStore...");
           var tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
           var tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
           tmf.init(keyStore);
           console.log("[+] Our TrustManager is ready...");

           console.log("[+] Hijacking SSLContext methods now...")
           console.log("[-] Waiting for the app to invoke SSLContext.init()...")

               SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").implementation = function(a,b,c) {
                       console.log("[o] App invoked javax.net.ssl.SSLContext.init...");
                       SSLContext.init.overload("[Ljavax.net.ssl.KeyManager;", "[Ljavax.net.ssl.TrustManager;", "java.security.SecureRandom").call(this, a, tmf.getTrustManagers(), c);
                       console.log("[+] SSLContext initialized with our custom TrustManager!");
               }
   });

},0);

```
