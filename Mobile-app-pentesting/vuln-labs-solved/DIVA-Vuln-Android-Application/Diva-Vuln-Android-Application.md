# DIVA Android Application Security Vulnerabilities Analysis

**Credits:**

**Rejaul Islam**  
_Security enthusiast_

............................................

## Application Overview

DIVA (Damn Insecure and Vulnerable App) is an intentionally vulnerable Android application designed for security education and penetration testing practice.

## 1. Insecure Logging Vulnerability

### What is it?

Insecure logging occurs when sensitive data (like passwords, tokens, or PII) is stored in log files without proper protection.

### How it occurs?

Developers log full request/response data, stack traces, or user input without masking sensitive information, making confidential data accessible through system logs.

### Step to Produce

1. Launch the DIVA application on your emulator or physical device
2. Open the application in jadx-gui tool and navigate to `LogActivity`
3. Analyze the vulnerable code:

```
public void checkout(View view) {
    EditText cctxt = (EditText) findViewById(R.id.ccText);
    try {
        processCC(cctxt.getText().toString());
    } catch (RuntimeException e) {
        Log.e("diva-log", "Error while processing transaction with credit card: " + cctxt.getText().toString());
        Toast.makeText(this, "An error occured. Please try again later", 0).show();
    }
}
```

4. Enter a credit card number in the application
5. Monitor logs using:

```
adb shell logcat | grep 'diva'
```

6. Observe the credit card number exposed in plain text within the logs

### Impact

Attackers accessing logs can steal credentials, session tokens, or personal data, leading to data breaches and financial fraud.

### Remediation

- Mask or encrypt sensitive data in logs
- Restrict log file access permissions
- Follow OWASP Logging Guidelines
- Implement proper log filtering mechanisms

## 2. Hardcoded Credentials - Part 1

### What is it?

Hardcoded credentials refer to storing sensitive information (like passwords, API keys, or URLs) directly in the source code.

### How it occurs?

Developers embed secrets in code for convenience or testing purposes and forget to remove them before deployment.

### Step to Produce

1. Open `HardcodedActivity` in jadx-gui
2. Examine the authentication logic:

```
EditText hckey = (EditText) findViewById(R.id.hcKey);
if (hckey.getText().toString().equals("vendorsecretkey"))
```

3. The hardcoded secret `vendorsecretkey` is visible in decompiled code
4. Enter `vendorsecretkey` in the application input field
5. Successfully bypass authentication using the extracted credential

### Impact

Attackers can extract secrets from code or binaries, leading to unauthorized access, system compromise, and potential data theft.

### Remediation

- Use environment variables or secure vaults for secrets
- Avoid embedding sensitive data in source code
- Implement proper key management systems
- Use build-time secret injection

## 3. Insecure Data Storage - Part 1

### What is it?

Insecure data storage occurs when sensitive data is stored without proper encryption or security controls.

### How it occurs?

Developers save data like passwords, tokens, or PII in plain text within local storage or unprotected databases.

### Step to Produce

1. Navigate to `InsecureData1Activity` in jadx-gui
2. Analyze the SharedPreferences implementation:

```
SharedPreferences spref = PreferenceManager.getDefaultSharedPreferences(this);
spedit.putString("user", usr.getText().toString());
spedit.putString("password", pwd.getText().toString());
spedit.commit();
```

3. Enter credentials in the application and save them
4. Access the stored data via ADB:

```
adb shell
cd /data/data/jakhar.aseem.diva/shared_prefs/
```

5. View the plain text credentials in SharedPreferences XML files

### Impact

Attackers accessing the device or storage can steal confidential data, leading to identity theft, account compromise, and data breaches.

### Remediation

- Encrypt sensitive data before storage
- Use Android's Keystore system for cryptographic keys
- Implement secure storage APIs
- Follow least privilege principles for data access

## 4. Insecure Data Storage - Part 2

### What is it?

SQLite database storage without encryption, exposing sensitive user credentials.

### How it occurs?

Developers use SQLite databases for local storage but fail to implement proper encryption and access controls.

### Step to Produce

1. Examine `InsecureDataStorage2Activity` in jadx-gui
2. Review the database creation and insertion code:

```
this.mDB = openOrCreateDatabase("ids2", 0, null);
this.mDB.execSQL("CREATE TABLE IF NOT EXISTS myuser(user VARCHAR, password VARCHAR);");
this.mDB.execSQL("INSERT INTO myuser VALUES ('" + usr.getText().toString() + "', '" + pwd.getText().toString() + "');");
```

3. Save credentials through the application interface
4. Access the database via ADB:

```
adb shell
cd /data/data/jakhar.aseem.diva/databases/
sqlite3 ids2
.tables
select * from myuser;
```

5. Observe plain text credentials in the database

### Impact

Direct database access exposes all stored credentials, enabling complete account compromise and potential lateral movement.

### Remediation

- Implement SQLCipher for database encryption
- Use parameterized queries to prevent injection
- Store only hashed and salted passwords
- Implement proper database permissions

## 5. Insecure Data Storage - Part 3

### What is it?

Temporary file storage with world-readable/writable permissions exposing sensitive data.

### How it occurs?

Developers create temporary files with improper permissions in application directories, making them accessible to other applications.

### Step to Produce

1. Analyze `InsecureDataStorage3Activity` in jadx-gui
2. Examine the file creation code:

```
File ddir = new File(getApplicationInfo().dataDir);
File uinfo = File.createTempFile("uinfo", "tmp", ddir);
uinfo.setReadable(true);
uinfo.setWritable(true);
FileWriter fw = new FileWriter(uinfo);
fw.write(usr.getText().toString() + ":" + pwd.getText().toString() + "\n");
```

3. Save credentials in the application
4. Access the temporary file:

```
adb shell
cd /data/data/jakhar.aseem.diva/
ls -la
cat [tmp_file_name]
```

5. View plain text credentials in the temporary file

### Impact

World-readable files allow any application on the device to access sensitive credentials, leading to widespread data exposure.

### Remediation

- Set proper file permissions (MODE_PRIVATE)
- Avoid storing sensitive data in temporary files
- Use encrypted storage for credentials
- Implement secure file deletion practices

## 6. Insecure Data Storage - Part 4

### What is it?

External storage usage with hidden files containing exposed credentials.

### How it occurs?

Developers store sensitive data on external storage (SD card) in hidden files, assuming they provide security through obscurity.

### Step to Produce

1. Before testing, ensure storage permissions are granted to the application
2. Examine the external storage implementation in jadx-gui
3. Save credentials through the application interface
4. Access the external storage:

```
adb shell
cd /sdcard
ls -la
cat .uinfo.txt
```

5. Observe plain text credentials in the hidden file

### Impact

External storage is accessible to all applications, making hidden files ineffective for security. Credentials are easily extractable by malicious apps.

### Remediation

- Avoid storing sensitive data on external storage
- If necessary, encrypt data before external storage
- Use internal storage for sensitive information
- Implement proper access controls

## 7. Input Validation Issues - Part 1 (SQL Injection)

### What is it?

SQL injection occurs when user inputs are not properly validated or sanitized before being used in database queries.

### How it occurs?

Applications directly concatenate user input into SQL queries without parameterization or validation.

### Step to Produce

1. Open `SqlInjectionActivity` in jadx-gui
2. Analyze the vulnerable query construction:

```
Cursor cr = this.mDB.rawQuery("SELECT * FROM sqliuser WHERE user = '" + srchtxt.getText().toString() + "'", null);
```

3. In the application, enter the SQL injection payload: `' OR 1=1 -- -`
4. Observe that all user records are returned instead of just the matched record

### Impact

Attackers can extract entire database contents, modify data, bypass authentication, and potentially execute administrative operations.

### Remediation

- Use parameterized queries or prepared statements
- Implement proper input validation and sanitization
- Apply the principle of least privilege to database accounts
- Use ORM frameworks with built-in protection

## 8. Input Validation Issues - Part 2 (URI Scheme Abuse)

### What is it?

URI scheme abuse occurs when applications load user-provided URLs without proper validation, enabling local file inclusion and malicious URL access.

### How it occurs?

Developers enable JavaScript and load user-provided URLs directly into WebView components without validation.

### Step to Produce

1. Examine `InputValidation2URISchemeActivity` in jadx-gui
2. Review the vulnerable WebView implementation:

```
wset.setJavaScriptEnabled(true);
public void get(View view) {
    EditText uriText = (EditText) findViewById(R.id.ivi2uri);
    WebView wview = (WebView) findViewById(R.id.ivi2wview);
    wview.loadUrl(uriText.getText().toString());
}
```

3. Test local file inclusion with: `file:///etc/hosts`
4. Test external URL loading with: `https://evil.com`

### Impact

Attackers can access local files, load malicious websites, and potentially execute cross-site scripting attacks within the application context.

### Remediation

- Validate and sanitize all URL inputs
- Restrict allowed URL schemes and domains
- Disable JavaScript unless absolutely necessary
- Implement URL allowlisting

## 9. Access Control Issues - Part 1

### What is it?

Access control issues occur when users can access resources or actions beyond their intended permissions due to improperly protected components.

### How it occurs?

Components are exported without proper permission checks, allowing unauthorized access from other applications.

### Step to Produce

1. Analyze `AccessControl1Activity` in jadx-gui
2. Examine the intent invocation:

```
public void viewAPICredentials(View view) {
    Intent i = new Intent();
    i.setAction("jakhar.aseem.diva.action.VIEW_CREDS");
    startActivity(i);
}
```

3. Check AndroidManifest.xml for exported activity configuration
4. Execute the intent externally:

```
adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS
```

5. Observe unauthorized access to API credentials

### Impact

Attackers can access sensitive functionality and data without authentication, leading to information disclosure and privilege escalation.

### Remediation

- Set `android:exported="false"` for internal components
- Implement custom permissions for inter-app communication
- Validate caller identity and permissions
- Use signature-level permissions for sensitive operations

## 10. Access Control Issues - Part 2

### What is it?

Client-side access control bypass where security decisions are made based on client-provided data that can be easily manipulated.

### How it occurs?

Applications trust client-side checks and data without server-side validation.

### Step to Produce

1. Examine `AccessControl2Activity` in jadx-gui
2. Analyze the client-side pin verification:

```
boolean chk_pin = rbregnow.isChecked();
i.putExtra(getString(R.string.chk_pin), chk_pin);
```

3. Review the receiving activity's trust in client data:

```
boolean bcheck = i.getBooleanExtra(getString(R.string.chk_pin), true);
if (!bcheck) {
    apicview.setText("TVEETER API Key: secrettveeterapikey\nAPI User name: diva2\nAPI Password: p@ssword2");
}
```

4. Bypass the pin check externally:

```
adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS2 --ez check_pin false
```

### Impact

Attackers can bypass authentication mechanisms, access privileged functionality, and retrieve sensitive information without proper authorization.

### Remediation

- Perform all access control checks server-side
- Never trust client-provided security flags
- Implement proper session management
- Use secure token-based authentication

## 11. Access Control Issues - Part 3

### What is it?

Insecure Content Provider implementation combined with weak PIN storage, allowing unauthorized data access.

### How it occurs?

Content Providers are exported without permissions, and authentication credentials are stored insecurely.

### Step to Produce

1. Analyze the Content Provider implementation in `NotesProvider`
2. Examine the insecure PIN storage in SharedPreferences
3. Review the access control logic in `AccessControl3NotesActivity`
4. Access the notes content provider externally:

```
// In attacker app
Uri uri = Uri.parse("content://jakhar.aseem.diva.notesprovider/notes");
Cursor cursor = getContentResolver().query(uri, null, null, null, null);
```

5. Extract all notes without authentication

### Impact

Complete bypass of application authentication, exposing all user notes and sensitive data to any installed application.

### Remediation

- Set Content Provider to non-exported if not needed externally
- Implement proper permission checks in Content Providers
- Store authentication data securely using encryption
- Validate user identity for all data access requests

## 12. Hardcoded Issues - Part 2 (Native Library)

### What is it?

Hardcoded secrets within native library code (JNI), accessible through reverse engineering.

### How it occurs?

Developers embed secrets in native C/C++ code, assuming they are harder to extract than Java code.

### Step to Produce

1. Examine `Hardcoded2Activity` and `DivaJni` class in jadx-gui
2. Identify the native method calls:

```
public class DivaJni {
    public native int access(String str);
    static {
        System.loadLibrary("divajni");
    }
}
```

3. Extract the native library from the APK
4. Analyze the library using tools like `strings` or examine the source from the official GitHub repository
5. Retrieve the vendor key from the native code implementation

### Impact

Secrets in native code are still accessible to determined attackers, leading to authentication bypass and system compromise.

### Remediation

- Avoid storing secrets in mobile applications
- Use remote configuration services
- Implement proper API authentication
- Use code obfuscation tools

## 13. Input Validation Issues - Part 3 (DoS Vulnerability)

### What is it?

Denial of Service vulnerability caused by lack of input validation, allowing resource exhaustion through excessive input.

### How it occurs?

Applications process user input without length or complexity checks, enabling resource consumption attacks.

### Step to Produce

1. Examine `InputValidation3Activity` in jadx-gui
2. Analyze the native method call without input validation:

```
public void push(View view) {
    EditText cTxt = (EditText) findViewById(R.id.ivi3CodeText);
    this.djni.initiateLaunchSequence(cTxt.getText().toString());
}
```

3. Enter an extremely long input string (thousands of characters)
4. Observe application crash or unresponsiveness

### Impact

Attackers can crash the application, cause resource exhaustion, or potentially exploit buffer overflow vulnerabilities in native code.

### Remediation

- Implement proper input length validation
- Add rate limiting for repeated requests
- Use safe programming practices in native code
- Perform bounds checking on all inputs

--- THE END ---
